"""Plug-In Manager for robot logic modules attaching to the core server application"""
#Importing necessary libraries
import importlib
import importlib.util
import os
import sys
from plugins.utils.plugin_interface import PluginInterface
import inspect
import pkgutil

#Plug-In Manager handling robot logic
class RobotLogicManager:

    #Initalizes the Plug-In Manager
    def __init__(self):

        #Path is subject to change (improving project structure)
        self.dir_path = os.path.dirname(os.path.realpath(__file__))
        self.plugin_directory = os.path.join(self.dir_path, "plugins")

        #Allows for Plugin discovery
        #Allows Python to search in the plugin directory
        sys.path.append(self.plugin_directory)
        
        #Allows Python to search in newly added plugins-subdirectories
        for folder in os.listdir(self.plugin_directory):
            path = os.path.join(self.plugin_directory, folder)
            if os.path.isdir(path) and path not in sys.path:
                sys.path.append(path)
        
        #Creates a dict of discovered plugins and their paths
        self.dicscovered_plugins = self.dicscover_plugins()

        #Mapping of ID to names of active plugins
        self.plugins = dict()

        #For the purpose of REST compliance every plugin will receive an ID
        #Mapping of ID to plugin instance
        self.plugin_mapping = dict()
        

    #Prints all instantiated plugins
    def show_all_running_plugins(self):
        print(PluginInterface.show_all_plugins(PluginInterface))

    #Source: https://gist.github.com/dorneanu/cce1cd6711969d581873a88e0257e312
    #Allows for the dynamic loading of modules
    #This is a very big function
    #It might profit from segmentation
    def load_module(self, path: str, plugin_id: str):
        #Gets filename from path
        name = os.path.split(path)[-1]
        #Creates a module spec
        spec = importlib.util.spec_from_file_location(name, path)
        #Creates a module from spec
        module = importlib.util.module_from_spec(spec)
        #Importing the Module
        spec.loader.exec_module(module)

        #Creating a module instance
        plugin_instance = self.instantiate_plugin(module)
        #Module management for further operations
        self.register_plugin(name, plugin_instance, plugin_id)
        
        #Only for testing, to be removed
        return plugin_instance
    
    #Creates and returns an instance of the main class of the plugin
    def instantiate_plugin(self, module: PluginInterface):
        #There should be only one class inheriting from PluginInterface
        for name, object in inspect.getmembers(module):
        #Check if the object is a class and subclasses PluginInterface
            if inspect.isclass(object) and issubclass(object, PluginInterface) and object != PluginInterface:
                #Instantiate the class
                plugin_instance = object()

        return plugin_instance
    
    #Discovers all plugins adhering to naming convention in the plugin directory
    #Naming convention: telepath_plugin_name (Telepath is the software name)
    def dicscover_plugins(self):
        discovered_plugins = {
            name: module_finder.find_spec(name).origin
            for module_finder, name, ispkg in pkgutil.iter_modules()
            if name.startswith('telepath_')
        }
        
        return discovered_plugins
    
    #Getter Method for discovered plugins
    def get_discovery(self):
        return self.dicscovered_plugins


    #Token generated by the TokenGenerator should be passed as an argument
    #Creates a mapping of IDs to plugin instances and of IDs to plugin names
    def register_plugin(self, plugin_name: str, plugin_instance: PluginInterface, plugin_id: str):

        #Saving plugin name for easier tracking
        self.plugins[plugin_id] = plugin_name

        #Allows the server to retrieve running instances of plugins for every client  
        self.plugin_mapping[plugin_id] = plugin_instance

    #Returns the correct plugin instance
    #According to the provided ID
    def get_plugin(self, plugin_id: str):
        instance = self.plugin_mapping[plugin_id]
        return instance
    
    #Remove plugin instances during log out
    def remove_plugin(self, plugin_id: str):
        self.plugin_mapping.pop(plugin_id)
        self.plugins.pop(plugin_id)